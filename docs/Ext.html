<HTML>
<HEAD>
<TITLE>extensions - Writing your own tags to be used in Merge pages.</TITLE>
<LINK REV="made" HREF="mailto:bhcompile@stripples.devel.redhat.com">
</HEAD>

<BODY>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<LI><A HREF="#types of tags">TYPES OF TAGS</A></LI>
	<UL>

		<LI><A HREF="#output tags">Output tags</A></LI>
		<LI><A HREF="#non block tags">Non block tags</A></LI>
		<LI><A HREF="#opening block tags">Opening block tags</A></LI>
		<LI><A HREF="#closing block tags">Closing block tags</A></LI>
	</UL>

	<LI><A HREF="#compilation process">COMPILATION PROCESS</A></LI>
	<LI><A HREF="#extension files">EXTENSION FILES</A></LI>
	<LI><A HREF="#extended tags syntax">EXTENDED TAGS SYNTAX</A></LI>
	<LI><A HREF="#implementing various tags">IMPLEMENTING VARIOUS TAGS</A></LI>
	<LI><A HREF="#macro tags">MACRO TAGS</A></LI>
	<LI><A HREF="#described tags">DESCRIBED TAGS</A></LI>
	<LI><A HREF="#mod perl compliance notice">MOD PERL COMPLIANCE NOTICE</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
<P>Merge extensions - Writing your own tags to be used in Merge pages.</P>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P>This file contains instructions as to how to create your own Merge tags.</P>
<P>
<HR>
<H1><A NAME="types of tags">TYPES OF TAGS</A></H1>
<P>Generally, there are four types of tags in Merge.</P>
<P>
<H2><A NAME="output tags">Output tags</A></H2>
<P>Tags such as &lt;$RVAR&gt; or others, that are substituted by values that appear
in the output. For example: &lt;$RVAR.x&gt; is substituted by the value of the
vairable x.</P>
<P>
<H2><A NAME="non block tags">Non block tags</A></H2>
<P>Tags that perform an action, and have no corresponding closing tags.
For example: &lt;$RSET.x='8'&gt; sets the value 8 into the variable x.</P>
<P>
<H2><A NAME="opening block tags">Opening block tags</A></H2>
<P>Tags that usually handle the flow of the template. These tags, together with
the closing tags, encapsulate a block of HTML and tags between them.
The data inside the block will be treated as regular output statements.
If you wish to capture it for a different use, a capturing mechanism
(for example, using the Perl <CODE>select()</CODE> statement) needs to be used.
For example, &lt;$RITERATION.LIMIT=4&gt; .. &lt;/$RITERATION&gt; will print everything
inside the block 4 times.</P>
<P>
<H2><A NAME="closing block tags">Closing block tags</A></H2>
<P>The tags that close blocks beginning in the opening tags.
The tags &lt;$REND&gt;, &lt;$REND_IF&gt; and &lt;$REND_WHILE&gt; are privilleged as closing
tags. Other closing tags use the SGML like notation of specifying a slash
before the name of the tag, for example: &lt;/$RCOUNT&gt; is the closing tag for
&lt;$RCOUNT&gt;</P>
<P>
<HR>
<H1><A NAME="compilation process">COMPILATION PROCESS</A></H1>
<P><STRONG>Do not execute, create code!</STRONG></P>
<P>When Merge scans the template, it does not interprete the program, but
creates Perl code to run it. The HTML code is converted to <CODE>print()</CODE> statements.
Non block tags are inserted as generated Perl code. Block tags are added as 
generated code, that encapsulate a perl operation on the code within.
Output tags depend on connotation: when specified in the middle of HTML code,
the generated code will be used as a parameter for print(). When specified
as part of a parameter for another tag, string concatenation is used to
create one string.
For example:</P>
<P>&lt;$RVAR.x&gt; is translated to : print ($vars{``x''});</P>
<P>&lt;$RQ.'&lt;$RVAR.x&gt;'&gt; is translated to: $engines{``''}.Query(``'' . ($vars{``x''}) . ``'')</P>
<P>In both cases, the code generated by &lt;$RVAR&gt; is an expression, not a list
of statements.</P>
<P>Notice, that when using *any* parameter gotten for a tag, either assumed to
be string or not, it must be encapsulated in double quotes.
Consider we are writing a tag &lt;$RSQR&gt; and generating the code
``sqr($x)''. If the user tried &lt;$RSQR.&lt;$RVAR.x&gt;&gt;, we will get
sqr(`` . $vars{''x``} . '') which is not what we intended.
Therefore we should create the code:
``sqr(\''$x\``)''
Which can be <CODE>sqr(``3'')</CODE> for &lt;$RSQR.3&gt; or sqr(``'' . $vars{``x''} . ``'') for
&lt;$RSQR.&lt;$RVAR.x&gt;&gt;.</P>
<P>Hint: sometimes you need to perform a few sentences for generating an output
tag. In this case it is better to create a function to run in runtime
in the extension module, for example:</P>
<PRE>
        sub Proper {
                my $str = shift;
                $str =~ s/(\w+)/ucfirst(lc($1))/ge;
                $str;
        }</PRE>
<P>and generate the code: ``HTML::Merge::Ext::Proper(\''$x\``)''.
Note that all the functions in the extension files reside under
the namespace HTML::Merge::Ext.</P>
<P>You can access the variable $HTML::Merge::Ext::ENGINE, or simply
$ENGINE, to determine which engine was called for the tag.
The engine API is not documented yet and might change without a warning.</P>
<P>
<HR>
<H1><A NAME="extension files">EXTENSION FILES</A></H1>
<P>Extension files are created per site, as a file called merge.ext, residing
in the instance directory, or per server, in the file /etc/merge.ext.</P>
<P>
<HR>
<H1><A NAME="extended tags syntax">EXTENDED TAGS SYNTAX</A></H1>
<P>Every tag is defined as a function returning the Perl code for the tag.
The function must have a prototype cotaining only scalars, to represent
the number of input parameters.</P>
<P>If we defined a tag called &lt;$RUSER&gt; with two parameters, it will be called
as &lt;$RUSER.&lt;first parameter&gt;.&lt;second parameter&gt;&gt;. If parameters were
encapsulated with quotes, it's the job of the user defined function to
strip them.</P>
<P>All special chars in the parameters will be quoted with a leading backslash
using the function quotemeta. Special chars that were not quoted belong to
the generated code the parameters might already contain. We basically
encourage that you don't alter the parameters, except of stripping quotes
if necessary.</P>
<P>Here is an example for a tag called PLUS, that accepts two parameters,
and is substituted by the result of their addition in the output.
Notice that the function prototype is crucial.</P>
<PRE>
        sub OUT_PLUS ($$) {
                my ($a, $b) = @_;
                &quot;\&quot;$a\&quot; + \&quot;$b\&quot;&quot;; # Return perl code to perform the operation
        }</PRE>
<P>Notes:</P>
<OL>
<LI>
The prototype defines two parameters.
<P></P>
<LI>
The parameters must be encapsulated with <STRONG>double</STRONG> quotes, even though we
expect numbers.
<P>Here is how <STRONG>***NOT***</STRONG> to implement the tag:</P>
<PRE>
        sub OUT_PLUS ($$) {
                my ($a, $b) = @_;
                return $a + $b; # or equally WRONG:
                return '&quot;' . ($a + $b) . '&quot;''; 
        }</PRE>
<P>You should not perform the operation in compilation time, but enable it to
perform in run time. The second version will work for
&lt;$RPLUS.4.5&gt; but <STRONG>NOT</STRONG> for &lt;$RPLUS.5.&lt;$RVAR.a&gt;&gt;, which will result in a
hard coded zero.</P>
<P></P></OL>
<P>
<HR>
<H1><A NAME="implementing various tags">IMPLEMENTING VARIOUS TAGS</A></H1>
<P>Functions should be in all uppercase, and consist of a prefix describing
the type of the tag, an underscore, and the tag name. 
Merge is case insensitive, so don't try to define tags with lowercase names.</P>
<PRE>
        For a non block tag, use the prefix B&lt;API&gt;.
        For a block opening tag, use the prefix B&lt;OAPI&gt;.
        For a block ending tag, use the prefix B&lt;CAPI&gt;.
        For an output tag, use the prefix B&lt;OUT&gt;.</PRE>
<P>You can use the perl functions setvar, getvar and incvar to manipulate Merge
variables.</P>
<P>Here are some examples:</P>
<PRE>
        sub OAPI_CSV ($) {
                my $filename = shift;
                $filename =~ s/^\\([&quot;'])(.*)\\\1$/$2/; # Drop the quotes
                                                # in compilation time!
                &lt;&lt;EOM;
                open(I, &quot;$filename&quot;); # Must use double quotes!
                local (\$__headers) = scalar(&lt;I&gt;); # Do not use my() ! 
                chop \$__headers;
                local (\@__fields) = split(/,\\s*/, \$__headers);
                # Notice that we must escape variable names with backslashes
                while (&lt;I&gt;) {
                        chop;
                        my \@__data = split(/,\\s*/);
                        foreach my \$i (0 .. \$#__fields) {
                                setvar(\$__fields[\$i], \$__data[\$i]);
                        }
        EOM
        }</PRE>
<PRE>
        sub CAPI_CSV () {
                &quot;}&quot;;
        }</PRE>
<PRE>
        Here is how we would use it:</PRE>
<PRE>
        &lt;$RCSV.'/data/&lt;$RVAR.name&gt;'&gt;
                &lt;$RVAR.worker&gt; has salary &lt;$RVAR.salary&gt;&lt;BR&gt;
        &lt;/$RCSV&gt;</PRE>
<PRE>
        name could be 'workers.dat', and the file /data/workers.dat could be:</PRE>
<PRE>
        worker, salary, office
        Bill, 9999999999999, Redmond
        George, 0, White House</PRE>
<P>
<HR>
<H1><A NAME="macro tags">MACRO TAGS</A></H1>
<P>Macro tags define a tag by simply grouping merge code to be susbtituted under 
it. Suppose we have two tags, &lt;$RFIRST&gt; that takes two parameters, and 
&lt;$RSECOND&gt; that takes two as well, we could define the tag &lt;$RCOMBINED&gt;
this way:</P>
<PRE>
        sub MACRO_COMBINED ($$$) {
                &lt;&lt;'EOM';
        First $1 and $2: &lt;$RFIRST.$1.$2&gt;&lt;BR&gt;
        Second $2 and $3: &lt;$RSECOND.$2.$3&gt;&lt;BR&gt;
        EOM
        }</PRE>
<P>This tag can now be called with three parameters.
Note: You do not need to parse the parameters yourself in a Macro tag.
You need to return a string containing Merge code and references to the
parameters like in a shell script. Writing a prototype is still mandatory.</P>
<P>
<HR>
<H1><A NAME="described tags">DESCRIBED TAGS</A></H1>
<P>Until now, extension tags could be called only with a list of parameters separated by commas. But merge enables defining tags that take a syntax similar to Merge native tags.</P>
<P>Suppose we define a tag:</P>
<PRE>
        sub OUT_MINUS ($$) {
                my ($a, $b) = @_;
                qq!(&quot;$a&quot;) - (&quot;$b&quot;)!;
        }</PRE>
<P>Now suppose we define a description function:</P>
<PRE>
        sub DESC_MINUS {
                'U-U';
        }</PRE>
<P>We can now call the new tag: &lt;$RMINUS.7-6&gt; or &lt;$RMINUS.&lt;$RVAR.x&gt;-1&gt;
and so on.</P>
<P>All the non alpha characters in the description string stand for themselves.
The following letters are assigned:</P>
<PRE>
        U - Unquoted parameters (e.g. 9, ball, &lt;$RVAR.a&gt; etc).
        Q - Quote parameter, (e.g. 'building', &quot;quoted string&quot;, 'a &quot;parameter&quot; with &lt;$RVAR.a&gt; inside')
        E - Call can end here, rest of the parameters optional. For example, a tag with the description QE:Q-QE*Q can be called as either 'first', 'first':'second'-'third' or 'first':'second'-'third'*'fourth'.
        D - Either a dot or equal sign.</PRE>
<P>
<HR>
<H1><A NAME="mod perl compliance notice">MOD PERL COMPLIANCE NOTICE</A></H1>
<P>Merge implements the extensions by compiling them as Perl code into
Merge itself. Therefore, on a mod_perl driven web server with several
instances, extensions will be shared among all instances.</P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>

</BODY>

</HTML>
